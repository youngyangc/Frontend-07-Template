学习笔记
1. js中得数组 既是一个天然得队列又是又是一个天然得栈
    + 如果使用 shift() push() 或者 unshift() pop() 那它就是一个队列
    + 如果使用 push() pop() 或 ~~unshift()、shift()~~ {此种不推荐使用} 那它就是一个栈 
    + unshift()每次插入都将移动数组中每一个元素得位置，效率较低。解决方案：可使用reserve()倒叙之后用push来实现unshift()
2. 广度优先搜索
    1. 广度优先搜索是一个队列
    2. 我们将第一个点加入队列后，将1周围得2，3，4，5格位置依次加入队列，再将1移除，直到当前队列为空
3. 深度优先搜索
    1. 深度优先搜索是一个栈
    2. 和广度优先搜索的区别 只是在于一个数据结构上是queue还是stack，用代码表达得话就是 push()、shift()和 push()、pop()的区别
4. A*搜索的数据结构为排序的结构,即优先取出按我们预期规则的数（最小数、最大数等）
5. 关于childrenNodes和动态绘制的数组元素严格对应，父节点不能有回车空格否则会差了一个文本节点
6. A*实现逻辑[参考网页](https://www.redblobgames.com/ )：
    + 给定一个优先级队列`queue`（排序、二叉树等），我们将每个格子的位置信息和每个格子到终点的优先值，每次取出成本值最低的格进行搜索
    + 优先值`priority`的计算逻辑： 搜索格子的成本值（`cost(next)`） + 搜索格子到终点的距离(`distance(next,end)`)
    + 成本值(cost)的计算逻辑：设置初始位置的成本值为1（因为0在Boolean判断中为false方便处理设置为1） 每次搜索到下一格的成本值为：(`cost(current)+distance(current,next)`)发起搜索格子的成本值+发起搜索格子到当前搜索格子的距离
    + 搜索格子到终点的距离(`distance(next,end)`) = `(end[0] - x)**2 + (end[1] - y)**2`因为不存在小数情况故可以不用开根号(如果有斜线情况需要开根号！因为当长度为1时 1^2+1^2= 2)
    + 每次优先值写入的条件（or）：
        1. 当前搜索格的位置是合理的（不超过规定范围；是可通行的格子）
        2. 当前搜索格的成本值没有记录过
        3. 当前搜索格的成本值比之前记录的成本值低（即：此时到当前搜索格的起始格子才是最优解）
    + 当满满足上述条件时我们需要写入如下信息：
        1. 搜索格子的成本值 即 `cost(next)`
        2. 在`queue`中存入 搜索格子的坐标`x,y`、优先值`priority`
        3. 搜索格子的前一个格子来源`came_from`
    + 此时最后搜寻到最后的终点就能找到一条优先值最高的路径。
